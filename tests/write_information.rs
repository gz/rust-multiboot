extern crate core;
extern crate multiboot;

use core::mem;
use multiboot::information::{
    ColorInfoType, ColorInfoRgb, ElfSymbols, FramebufferTable, MemoryEntry, MemoryManagement,
    MemoryType, Module, Multiboot, MultibootInfo, PAddr, SymbolType,
};

struct Mem {
    string_buffer: [u8; 5],
    module_buffer: [u8; 16],
}

impl Mem {
    fn new() -> Self {
        Self {
            string_buffer: [0; 5],
            module_buffer: [0; 16],
        }
    }
}

impl MemoryManagement for Mem {
    unsafe fn paddr_to_slice(&self, _addr: PAddr, _size: usize) -> Option<&'static [u8]> {
        None
    }
    
    unsafe fn allocate(&mut self, length: usize) -> Option<(PAddr, &mut [u8])> {
        match length {
            5 => Some((0x12345678, &mut self.string_buffer)), // for our test string
            16 => Some((0xaaaaaaaa, &mut self.module_buffer)), // four our test module
            _ => None,
        }
    }
    
    unsafe fn deallocate(&mut self, addr: PAddr) {
        if addr != 0 {
            unimplemented!()
        }
    }
}

#[test]
/// Just create an empty struct.
fn empty() {
    let mut mem = Mem::new();
    let mut info = MultibootInfo::default();
    let mut multiboot = Multiboot::from_ref(&mut info, &mut mem);
    // this has no effect here, but it should still work
    multiboot.set_memory_bounds(None);
    multiboot.set_command_line(None);
    multiboot.set_modules(None);
    multiboot.set_symbols(None);
    multiboot.set_memory_regions(None);
    multiboot.set_boot_loader_name(None);
    multiboot.set_framebuffer_table(None);
    let expected: [u8; 120] = [
        0x00, 0x00, 0x00, 0x00, // flags
        0x00, 0x00, 0x00, 0x00, // mem_lower
        0x00, 0x00, 0x00, 0x00, // mem_upper
        0xff, 0xff, 0xff, 0xff, // boot_device
        0x00, 0x00, 0x00, 0x00, // cmdline
        0x00, 0x00, 0x00, 0x00, // mods_count
        0x00, 0x00, 0x00, 0x00, // mods_addr
        0x00, 0x00, 0x00, 0x00, // syms1
        0x00, 0x00, 0x00, 0x00, // syms2
        0x00, 0x00, 0x00, 0x00, // syms3
        0x00, 0x00, 0x00, 0x00, // syms4
        0x00, 0x00, 0x00, 0x00, // mmap_length
        0x00, 0x00, 0x00, 0x00, // mmap_addr
        0x00, 0x00, 0x00, 0x00, // drives_length
        0x00, 0x00, 0x00, 0x00, // drives_addr
        0x00, 0x00, 0x00, 0x00, // config_table
        0x00, 0x00, 0x00, 0x00, // boot_loader_name
        0x00, 0x00, 0x00, 0x00, // apm_table
        0x00, 0x00, 0x00, 0x00, // vbe_control_info
        0x00, 0x00, 0x00, 0x00, // vbe_mode_info
        0x00, 0x00, // vbe_mode
        0x00, 0x00, // vbe_interface_seg
        0x00, 0x00, // vbe_interface_off
        0x00, 0x00, // vbe_interface_len
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // framebuffer_addr
        0x00, 0x00, 0x00, 0x00, // framebuffer_pitch
        0x00, 0x00, 0x00, 0x00, // framebuffer_width
        0x00, 0x00, 0x00, 0x00, // framebuffer_height
        0x00, // framebuffer_bpp
        0x00, // framebuffer_type
        0x00, 0x00, // alignment
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // color_info
        0x00, 0x00, // alignment
    ];
    assert_eq!(unsafe { mem::transmute::<_, [u8; 120]>(info) }, expected);
}

#[test]
/// Set memory bounds.
fn memory_bounds() {
    let mut mem = Mem::new();
    let mut info = MultibootInfo::default();
    let mut multiboot = Multiboot::from_ref(&mut info, &mut mem);
    multiboot.set_memory_bounds(Some((640, 8 * 1024)));
    let expected: [u8; 120] = [
        0x01, 0x00, 0x00, 0x00, // flags
        0x80, 0x02, 0x00, 0x00, // mem_lower
        0x00, 0x20, 0x00, 0x00, // mem_upper
        0xff, 0xff, 0xff, 0xff, // boot_device
        0x00, 0x00, 0x00, 0x00, // cmdline
        0x00, 0x00, 0x00, 0x00, // mods_count
        0x00, 0x00, 0x00, 0x00, // mods_addr
        0x00, 0x00, 0x00, 0x00, // syms1
        0x00, 0x00, 0x00, 0x00, // syms2
        0x00, 0x00, 0x00, 0x00, // syms3
        0x00, 0x00, 0x00, 0x00, // syms4
        0x00, 0x00, 0x00, 0x00, // mmap_length
        0x00, 0x00, 0x00, 0x00, // mmap_addr
        0x00, 0x00, 0x00, 0x00, // drives_length
        0x00, 0x00, 0x00, 0x00, // drives_addr
        0x00, 0x00, 0x00, 0x00, // config_table
        0x00, 0x00, 0x00, 0x00, // boot_loader_name
        0x00, 0x00, 0x00, 0x00, // apm_table
        0x00, 0x00, 0x00, 0x00, // vbe_control_info
        0x00, 0x00, 0x00, 0x00, // vbe_mode_info
        0x00, 0x00, // vbe_mode
        0x00, 0x00, // vbe_interface_seg
        0x00, 0x00, // vbe_interface_off
        0x00, 0x00, // vbe_interface_len
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // framebuffer_addr
        0x00, 0x00, 0x00, 0x00, // framebuffer_pitch
        0x00, 0x00, 0x00, 0x00, // framebuffer_width
        0x00, 0x00, 0x00, 0x00, // framebuffer_height
        0x00, // framebuffer_bpp
        0x00, // framebuffer_type
        0x00, 0x00, // alignment
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // color_info
        0x00, 0x00, // alignment
    ];
    assert_eq!(unsafe { mem::transmute::<_, [u8; 120]>(info) }, expected);
}

#[test]
/// Also set the command line.
fn command_line() {
    let mut mem = Mem::new();
    let mut info = MultibootInfo::default();
    let mut multiboot = Multiboot::from_ref(&mut info, &mut mem);
    multiboot.set_command_line(Some("test"));
    let expected: [u8; 120] = [
        0x04, 0x00, 0x00, 0x00, // flags
        0x00, 0x00, 0x00, 0x00, // mem_lower
        0x00, 0x00, 0x00, 0x00, // mem_upper
        0xff, 0xff, 0xff, 0xff, // boot_device
        0x78, 0x56, 0x34, 0x12, // cmdline
        0x00, 0x00, 0x00, 0x00, // mods_count
        0x00, 0x00, 0x00, 0x00, // mods_addr
        0x00, 0x00, 0x00, 0x00, // syms1
        0x00, 0x00, 0x00, 0x00, // syms2
        0x00, 0x00, 0x00, 0x00, // syms3
        0x00, 0x00, 0x00, 0x00, // syms4
        0x00, 0x00, 0x00, 0x00, // mmap_length
        0x00, 0x00, 0x00, 0x00, // mmap_addr
        0x00, 0x00, 0x00, 0x00, // drives_length
        0x00, 0x00, 0x00, 0x00, // drives_addr
        0x00, 0x00, 0x00, 0x00, // config_table
        0x00, 0x00, 0x00, 0x00, // boot_loader_name
        0x00, 0x00, 0x00, 0x00, // apm_table
        0x00, 0x00, 0x00, 0x00, // vbe_control_info
        0x00, 0x00, 0x00, 0x00, // vbe_mode_info
        0x00, 0x00, // vbe_mode
        0x00, 0x00, // vbe_interface_seg
        0x00, 0x00, // vbe_interface_off
        0x00, 0x00, // vbe_interface_len
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // framebuffer_addr
        0x00, 0x00, 0x00, 0x00, // framebuffer_pitch
        0x00, 0x00, 0x00, 0x00, // framebuffer_width
        0x00, 0x00, 0x00, 0x00, // framebuffer_height
        0x00, // framebuffer_bpp
        0x00, // framebuffer_type
        0x00, 0x00, // alignment
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // color_info
        0x00, 0x00, // alignment
    ];
    assert_eq!(unsafe { mem::transmute::<_, [u8; 120]>(info) }, expected);
    assert_eq!(mem.string_buffer, [0x74, 0x65, 0x73, 0x74, 0x00]); // 'test'
}

#[test]
/// Set modules.
fn modules() {
    let mut mem = Mem::new();
    let mut info = MultibootInfo::default();
    let mut multiboot = Multiboot::from_ref(&mut info, &mut mem);
    multiboot.set_modules(Some(&[Module::new(0x12345678, 0x87654321, Some("test"))]));
    let expected: [u8; 120] = [
        0x08, 0x00, 0x00, 0x00, // flags
        0x00, 0x00, 0x00, 0x00, // mem_lower
        0x00, 0x00, 0x00, 0x00, // mem_upper
        0xff, 0xff, 0xff, 0xff, // boot_device
        0x00, 0x00, 0x00, 0x00, // cmdline
        0x01, 0x00, 0x00, 0x00, // mods_count
        0xaa, 0xaa, 0xaa, 0xaa, // mods_addr
        0x00, 0x00, 0x00, 0x00, // syms1
        0x00, 0x00, 0x00, 0x00, // syms2
        0x00, 0x00, 0x00, 0x00, // syms3
        0x00, 0x00, 0x00, 0x00, // syms4
        0x00, 0x00, 0x00, 0x00, // mmap_length
        0x00, 0x00, 0x00, 0x00, // mmap_addr
        0x00, 0x00, 0x00, 0x00, // drives_length
        0x00, 0x00, 0x00, 0x00, // drives_addr
        0x00, 0x00, 0x00, 0x00, // config_table
        0x00, 0x00, 0x00, 0x00, // boot_loader_name
        0x00, 0x00, 0x00, 0x00, // apm_table
        0x00, 0x00, 0x00, 0x00, // vbe_control_info
        0x00, 0x00, 0x00, 0x00, // vbe_mode_info
        0x00, 0x00, // vbe_mode
        0x00, 0x00, // vbe_interface_seg
        0x00, 0x00, // vbe_interface_off
        0x00, 0x00, // vbe_interface_len
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // framebuffer_addr
        0x00, 0x00, 0x00, 0x00, // framebuffer_pitch
        0x00, 0x00, 0x00, 0x00, // framebuffer_width
        0x00, 0x00, 0x00, 0x00, // framebuffer_height
        0x00, // framebuffer_bpp
        0x00, // framebuffer_type
        0x00, 0x00, // alignment
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // color_info
        0x00, 0x00, // alignment
    ];
    assert_eq!(unsafe { mem::transmute::<_, [u8; 120]>(info) }, expected);
    assert_eq!(mem.string_buffer, [0x74, 0x65, 0x73, 0x74, 0x00]); // 'test'
    assert_eq!(mem.module_buffer, [
        0x78, 0x56, 0x34, 0x12, // start
        0x21, 0x43, 0x65, 0x87, // end
        0x78, 0x56, 0x34, 0x12, // TEST_STR
        0x00, 0x00, 0x00, 0x00 // reserved
    ]);
}

#[test]
/// Set symbols.
fn symbols() {
    let mut mem = Mem::new();
    let mut info = MultibootInfo::default();
    let mut multiboot = Multiboot::from_ref(&mut info, &mut mem);
    multiboot.set_symbols(Some(SymbolType::Elf(ElfSymbols::from_addr(
        1, 8, 0x12345678, 0
    ))));
    let expected: [u8; 120] = [
        0x20, 0x00, 0x00, 0x00, // flags
        0x00, 0x00, 0x00, 0x00, // mem_lower
        0x00, 0x00, 0x00, 0x00, // mem_upper
        0xff, 0xff, 0xff, 0xff, // boot_device
        0x00, 0x00, 0x00, 0x00, // cmdline
        0x00, 0x00, 0x00, 0x00, // mods_count
        0x00, 0x00, 0x00, 0x00, // mods_addr
        0x01, 0x00, 0x00, 0x00, // syms1
        0x08, 0x00, 0x00, 0x00, // syms2
        0x78, 0x56, 0x34, 0x12, // syms3
        0x00, 0x00, 0x00, 0x00, // syms4
        0x00, 0x00, 0x00, 0x00, // mmap_length
        0x00, 0x00, 0x00, 0x00, // mmap_addr
        0x00, 0x00, 0x00, 0x00, // drives_length
        0x00, 0x00, 0x00, 0x00, // drives_addr
        0x00, 0x00, 0x00, 0x00, // config_table
        0x00, 0x00, 0x00, 0x00, // boot_loader_name
        0x00, 0x00, 0x00, 0x00, // apm_table
        0x00, 0x00, 0x00, 0x00, // vbe_control_info
        0x00, 0x00, 0x00, 0x00, // vbe_mode_info
        0x00, 0x00, // vbe_mode
        0x00, 0x00, // vbe_interface_seg
        0x00, 0x00, // vbe_interface_off
        0x00, 0x00, // vbe_interface_len
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // framebuffer_addr
        0x00, 0x00, 0x00, 0x00, // framebuffer_pitch
        0x00, 0x00, 0x00, 0x00, // framebuffer_width
        0x00, 0x00, 0x00, 0x00, // framebuffer_height
        0x00, // framebuffer_bpp
        0x00, // framebuffer_type
        0x00, 0x00, // alignment
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // color_info
        0x00, 0x00, // alignment
    ];
    assert_eq!(unsafe { mem::transmute::<_, [u8; 120]>(info) }, expected);
}

#[test]
/// Set memory regions.
fn mmap() {
    let mut mem = Mem::new();
    let mut info = MultibootInfo::default();
    let mut multiboot = Multiboot::from_ref(&mut info, &mut mem);
    multiboot.set_memory_regions(Some((0x12345678, 1)));
    let expected: [u8; 120] = [
        0x40, 0x00, 0x00, 0x00, // flags
        0x00, 0x00, 0x00, 0x00, // mem_lower
        0x00, 0x00, 0x00, 0x00, // mem_upper
        0xff, 0xff, 0xff, 0xff, // boot_device
        0x00, 0x00, 0x00, 0x00, // cmdline
        0x00, 0x00, 0x00, 0x00, // mods_count
        0x00, 0x00, 0x00, 0x00, // mods_addr
        0x00, 0x00, 0x00, 0x00, // syms1
        0x00, 0x00, 0x00, 0x00, // syms2
        0x00, 0x00, 0x00, 0x00, // syms3
        0x00, 0x00, 0x00, 0x00, // syms4
        0x18, 0x00, 0x00, 0x00, // mmap_length
        0x78, 0x56, 0x34, 0x12, // mmap_addr
        0x00, 0x00, 0x00, 0x00, // drives_length
        0x00, 0x00, 0x00, 0x00, // drives_addr
        0x00, 0x00, 0x00, 0x00, // config_table
        0x00, 0x00, 0x00, 0x00, // boot_loader_name
        0x00, 0x00, 0x00, 0x00, // apm_table
        0x00, 0x00, 0x00, 0x00, // vbe_control_info
        0x00, 0x00, 0x00, 0x00, // vbe_mode_info
        0x00, 0x00, // vbe_mode
        0x00, 0x00, // vbe_interface_seg
        0x00, 0x00, // vbe_interface_off
        0x00, 0x00, // vbe_interface_len
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // framebuffer_addr
        0x00, 0x00, 0x00, 0x00, // framebuffer_pitch
        0x00, 0x00, 0x00, 0x00, // framebuffer_width
        0x00, 0x00, 0x00, 0x00, // framebuffer_height
        0x00, // framebuffer_bpp
        0x00, // framebuffer_type
        0x00, 0x00, // alignment
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // color_info
        0x00, 0x00, // alignment
    ];
    assert_eq!(unsafe { mem::transmute::<_, [u8; 120]>(info) }, expected);
    let memory_entry = MemoryEntry::new(0x12345678, 4096, MemoryType::Defect);
    let expected_entry: [u8; 24] = [
        0x14, 0x00, 0x00, 0x00, // size
        0x78, 0x56, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00, // base_addr
        0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // length
        0x05, 0x00, 0x00, 0x00, // type
    ];
    assert_eq!(unsafe { mem::transmute::<_, [u8; 24]>(memory_entry) }, expected_entry);
}

#[test]
/// Also set the boot loader name.
fn boot_loader_name() {
    let mut mem = Mem::new();
    let mut info = MultibootInfo::default();
    let mut multiboot = Multiboot::from_ref(&mut info, &mut mem);
    multiboot.set_boot_loader_name(Some("test"));
    let expected: [u8; 120] = [
        0x00, 0x02, 0x00, 0x00, // flags
        0x00, 0x00, 0x00, 0x00, // mem_lower
        0x00, 0x00, 0x00, 0x00, // mem_upper
        0xff, 0xff, 0xff, 0xff, // boot_device
        0x00, 0x00, 0x00, 0x00, // cmdline
        0x00, 0x00, 0x00, 0x00, // mods_count
        0x00, 0x00, 0x00, 0x00, // mods_addr
        0x00, 0x00, 0x00, 0x00, // syms1
        0x00, 0x00, 0x00, 0x00, // syms2
        0x00, 0x00, 0x00, 0x00, // syms3
        0x00, 0x00, 0x00, 0x00, // syms4
        0x00, 0x00, 0x00, 0x00, // mmap_length
        0x00, 0x00, 0x00, 0x00, // mmap_addr
        0x00, 0x00, 0x00, 0x00, // drives_length
        0x00, 0x00, 0x00, 0x00, // drives_addr
        0x00, 0x00, 0x00, 0x00, // config_table
        0x78, 0x56, 0x34, 0x12, // boot_loader_name
        0x00, 0x00, 0x00, 0x00, // apm_table
        0x00, 0x00, 0x00, 0x00, // vbe_control_info
        0x00, 0x00, 0x00, 0x00, // vbe_mode_info
        0x00, 0x00, // vbe_mode
        0x00, 0x00, // vbe_interface_seg
        0x00, 0x00, // vbe_interface_off
        0x00, 0x00, // vbe_interface_len
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // framebuffer_addr
        0x00, 0x00, 0x00, 0x00, // framebuffer_pitch
        0x00, 0x00, 0x00, 0x00, // framebuffer_width
        0x00, 0x00, 0x00, 0x00, // framebuffer_height
        0x00, // framebuffer_bpp
        0x00, // framebuffer_type
        0x00, 0x00, // alignment
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // color_info
        0x00, 0x00, // alignment
    ];
    assert_eq!(unsafe { mem::transmute::<_, [u8; 120]>(info) }, expected);
    assert_eq!(mem.string_buffer, [0x74, 0x65, 0x73, 0x74, 0x00]); // 'test'
}

#[test]
/// Set framebuffer information.
fn framebuffer() {
    let mut mem = Mem::new();
    let mut info = MultibootInfo::default();
    let mut multiboot = Multiboot::from_ref(&mut info, &mut mem);
    multiboot.set_framebuffer_table(Some(FramebufferTable::new(
        0x12345678, 800 * 4, 800, 600, 32, ColorInfoType::Rgb(ColorInfoRgb {
            red_field_position: 0,
            red_mask_size: 8,
            green_field_position: 8,
            green_mask_size: 8,
            blue_field_position: 16,
            blue_mask_size: 8,
        }),
    )));
    let expected: [u8; 120] = [
        0x00, 0x10, 0x00, 0x00, // flags
        0x00, 0x00, 0x00, 0x00, // mem_lower
        0x00, 0x00, 0x00, 0x00, // mem_upper
        0xff, 0xff, 0xff, 0xff, // boot_device
        0x00, 0x00, 0x00, 0x00, // cmdline
        0x00, 0x00, 0x00, 0x00, // mods_count
        0x00, 0x00, 0x00, 0x00, // mods_addr
        0x00, 0x00, 0x00, 0x00, // syms1
        0x00, 0x00, 0x00, 0x00, // syms2
        0x00, 0x00, 0x00, 0x00, // syms3
        0x00, 0x00, 0x00, 0x00, // syms4
        0x00, 0x00, 0x00, 0x00, // mmap_length
        0x00, 0x00, 0x00, 0x00, // mmap_addr
        0x00, 0x00, 0x00, 0x00, // drives_length
        0x00, 0x00, 0x00, 0x00, // drives_addr
        0x00, 0x00, 0x00, 0x00, // config_table
        0x00, 0x00, 0x00, 0x00, // boot_loader_name
        0x00, 0x00, 0x00, 0x00, // apm_table
        0x00, 0x00, 0x00, 0x00, // vbe_control_info
        0x00, 0x00, 0x00, 0x00, // vbe_mode_info
        0x00, 0x00, // vbe_mode
        0x00, 0x00, // vbe_interface_seg
        0x00, 0x00, // vbe_interface_off
        0x00, 0x00, // vbe_interface_len
        0x78, 0x56, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00, // framebuffer_addr
        0x80, 0x0c, 0x00, 0x00, // framebuffer_pitch
        0x20, 0x03, 0x00, 0x00, // framebuffer_width
        0x58, 0x02, 0x00, 0x00, // framebuffer_height
        0x20, // framebuffer_bpp
        0x01, // framebuffer_type
        0x00, 0x00, // alignment
        0x00, 0x08, 0x08, 0x08, 0x10, 0x08, // color_info
        0x00, 0x00, // alignment
    ];
    assert_eq!(unsafe { mem::transmute::<_, [u8; 120]>(info) }, expected);
}
